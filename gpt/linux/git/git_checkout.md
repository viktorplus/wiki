````markdown
# Шпаргалка по `git checkout`

`git checkout` — старшая «универсальная» команда Git для:

1. **Переключения веток**
2. **Создания веток**
3. **Перехода на конкретный коммит/тег (detached HEAD)**
4. **Восстановления файлов из коммита (отмена изменений)**

> Сейчас часть функционала разнесена по командам:  
> `git switch` — про ветки,  
> `git restore` — про файлы.  
> Но `git checkout` активно используется в документации и туториалах, поэтому её нужно знать.

---

## 1. Базовый синтаксис

```bash
git checkout <ветка>
git checkout -b <новая_ветка> [база]
git checkout <коммит|тег>
git checkout [<коммит>] -- <файл/путь>
````

Грубо:

- **Без `--`** → работа с ветками/коммитами.
    
- **С `--`** → работа с файлами.
    

---

## 2. Переключение между ветками

### 2.1. Переключиться на существующую ветку

```bash
git checkout main
git checkout feature/login
```

Что делает:

- `HEAD` начинает указывать на выбранную ветку.
    
- Рабочая директория и индекс обновляются под состояние этой ветки.
    

> ⚠️ Если есть незакоммиченные изменения, которые конфликтуют с целевой веткой, Git может отказать или потребовать `-f`.

---

## 3. Создание новой ветки

### 3.1. Создать ветку от текущего коммита и сразу перейти

```bash
git checkout -b feature/payments
```

Эквивалентно:

```bash
git branch feature/payments
git checkout feature/payments
```

### 3.2. Создать ветку от другой ветки или коммита

```bash
git checkout -b hotfix/login main     # от ветки main
git checkout -b debug 3f7a9c1         # от конкретного коммита
```

---

## 4. Переход на коммит / тег (detached HEAD)

### 4.1. Перейти на конкретный коммит

```bash
git checkout 3f7a9c1
```

### 4.2. Перейти на тег

```bash
git checkout v1.0.0
```

Результат:

- `HEAD` указывает **на коммит**, а не на ветку → состояние **detached HEAD**.
    
- Можно:
    
    - смотреть код в прошлом,
        
    - запускать тесты/приложение в этом состоянии.
        

Если создать коммиты в detached HEAD — они останутся «без ветки», пока не привязать их:

```bash
git checkout -b experiment   # или git switch -c experiment
```

---

## 5. Восстановление файлов (отмена изменений)

### 5.1. Вернуть файл к состоянию последнего коммита (`HEAD`)

```bash
git checkout -- config.py
# то же самое:
git checkout HEAD -- config.py
```

Что происходит:

- Берётся версия файла из последнего коммита на текущей ветке (HEAD).
    
- Рабочий файл перезаписывается.
    
- Незакоммиченные изменения в этом файле **теряются**.
    

### 5.2. Отменить изменения во всём проекте (ОПАСНО)

```bash
git checkout -- .
# или
git checkout HEAD -- .
```

- Все незакоммиченные изменения _по всему репо_ будут стерты.
    

---

## 6. Взять файл из другого коммита или ветки

### 6.1. Восстановить файл из старого коммита

```bash
git checkout 3f7a9c1 -- src/app.py
```

- Ты остаёшься на текущей ветке.
    
- Git берёт `src/app.py` из коммита `3f7a9c1` и кладёт в рабочую директорию (и индекс).
    
- Можно потом сделать коммит с этой версией файла.
    

### 6.2. Взять файл из другой ветки

```bash
git checkout main -- src/app.py   # взять файл из ветки main
```

---

## 7. Работа с удалёнными ветками

### 7.1. Создать локальную ветку из удалённой и перейти

После `git fetch`:

```bash
git checkout -b feature/api origin/feature/api
```

Современные версии Git позволяют просто:

```bash
git checkout feature/api
```

если локальной ветки нет, но есть `origin/feature/api`.

---

## 8. Форсированный checkout

Если при переключении Git ругается:

> error: Your local changes to the following files would be overwritten by checkout

Можно **принудительно**:

```bash
git checkout -f main
```

- Все конфликтующие незакоммиченные изменения будут **удалены**.
    
- Использовать только если ты точно не жалеешь эти изменения.
    

---

## 9. Полезные ключи `git checkout`

### 9.1. `-b` — создать и сразу перейти

```bash
git checkout -b feature/ui
```

### 9.2. `-B` — создать/перезаписать ветку

```bash
git checkout -B feature/ui main
```

- Если `feature/ui` уже есть — она будет «переброшена» на `main`.
    

### 9.3. `--detach` — явный detached HEAD

```bash
git checkout --detach 3f7a9c1
```

То же, что просто `git checkout 3f7a9c1`, но явно: ты входишь в detached HEAD осознанно.

### 9.4. `--` — разделитель между ревизией и путём

Важно, если имя ветки и файла совпадают:

```bash
git checkout mybranch          # интерпретируется как ветка
git checkout -- mybranch       # интерпретируется как файл/папка
git checkout HEAD -- mybranch  # файл/папка из HEAD
```

---

## 10. Конфликты слияния: `--ours` и `--theirs`

При merge-конфликте можно забрать полностью «нашу» или «их» версию файла:

```bash
git checkout --ours  src/app.py
git checkout --theirs src/app.py
git add src/app.py
```

- `--ours` — версия из текущей ветки (куда вливаем).
    
- `--theirs` — версия из вливаемой ветки.
    

После checkout обязательно сделать `git add`, чтобы отметить файл как решённый.

---

## 11. Интерактивный `checkout` по кускам (`-p`)

Можно брать изменения **частями** (hunks):

```bash
git checkout -p -- src/app.py
```

Git покажет фрагменты изменений и будет спрашивать, какие применить.

---

## 12. Связь `git checkout` с `git switch` и `git restore`

Современная рекомендация:

- Для веток:
    
    ```bash
    git switch main
    git switch -c feature/api
    ```
    
- Для файлов:
    
    ```bash
    git restore config.py
    git restore --source=3f7a9c1 src/app.py
    ```
    

Но под капотом это логика `checkout`. Старые проекты и документация всё ещё массово используют именно `git checkout`.

---

## 13. Быстрая таблица по типовым задачам

|Задача|Команда|
|---|---|
|Переключиться на ветку|`git checkout main`|
|Создать ветку и перейти в неё|`git checkout -b feature/auth`|
|Создать ветку от `main`|`git checkout -b feature/auth main`|
|Перейти в состояние старого коммита|`git checkout 3f7a9c1`|
|Вернуться обратно на ветку|`git checkout main`|
|Вернуть файл как в последнем коммите|`git checkout -- src/settings.py`|
|Вернуть файл как 3 коммита назад|`git checkout HEAD~3 -- src/settings.py`|
|Взять файл из ветки `main`|`git checkout main -- src/settings.py`|
|Выкинуть все незакоммиченные изменения|`git checkout -- .`|
|Форс-переключение, потеряв изменения|`git checkout -f main`|
|Взять «нашу» версию файла при конфликте|`git checkout --ours src/app.py`|
|Взять «их» версию файла при конфликте|`git checkout --theirs src/app.py`|
|Создать локальную ветку из `origin/feature`|`git checkout -b feature origin/feature`|

---

```

Если хочешь, могу сделать вторую шпаргалку-таблицу: `старый checkout → современный switch/restore` по типичным сценариям, чтобы легче привыкать к новым командам.
::contentReference[oaicite:0]{index=0}
```