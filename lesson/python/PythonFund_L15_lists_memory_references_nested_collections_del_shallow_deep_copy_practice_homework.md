# Python Fundamentals — Урок 15: списки и память (ссылки, вложенные коллекции, `del`, shallow/deep copy)

## 0) О чём урок
Сегодня всё про **то, как Python хранит списки в памяти**, почему «копирование» часто оказывается **ссылкой**, как работать с **вложенными списками**, что делает `del`, и чем отличается **поверхностное** и **глубокое** копирование.

---

## 1) Изменяемые типы и память (heap)
### 1.1 Изменяемые (mutable) типы
Изменяемые структуры данных можно менять «на месте» (без создания нового объекта):
- `list`, `dict`, `set` — **mutable**
- `int`, `float`, `str`, `tuple` — **immutable**

**Что это даёт:**
- экономия памяти и скорость (объект не пересоздаётся),
- но легко поймать баг с «общей ссылкой».

### 1.2 Куча (heap)
Все объекты Python живут в **куче** — области динамической памяти.
Переменные хранят **ссылки** на объекты (а не сами объекты).

---

## 2) `id()` и ссылки
`id(obj)` возвращает уникальный идентификатор объекта (в CPython это обычно адрес/псевдо-адрес в памяти, но трактуем как «уникальный ID пока объект жив»).

```py
a = [1, 2, 3]
b = a
print(id(a), id(b))  # одинаковые -> это один и тот же объект
```

Если создаём новый список с теми же значениями:
```py
c = [1, 2, 3]
print(id(a) == id(c))  # False -> разные объекты
```

---

## 3) Как работает присваивание (самая частая причина багов)
### 3.1 Неизменяемые объекты
При «изменении» создаётся новый объект:
```py
text1 = "hello"
text2 = text1
text1 + " Python"      # новый объект, text1 не меняется
text2 += " world"      # text2 теперь указывает на новый объект
```

### 3.2 Изменяемые объекты (списки)
Присваивание копирует **ссылку**, и изменения видны через обе переменные:
```py
list_a = [1, 2, 3]
list_b = list_a

list_b.append(4)
print(list_a)  # [1, 2, 3, 4]
print(list_b)  # [1, 2, 3, 4]

list_b[0] = "new"
print(list_a)  # ['new', 2, 3, 4]
```

✅ Правило:
- `b = a` **не копирует список**, а делает «второе имя» (aliasing).

---

## 4) Вложенные коллекции (nested collections)
**Вложенные коллекции** — когда элементы коллекции сами являются коллекциями.

Примеры:
```py
list_elements = [[1, 2, 3], [4, 5], 6, [7], [8, 9]]
lists_tuple = ([1, 2], [3, 4], [5, 6])  # кортеж со списками
lists = [[1, 2], [3, 4]]
```

---

## 5) Доступ к вложенным элементам (индексация уровнями)
```py
list_elements = [[1, 2, 3], [4, 5], 6, [7, [8, [9], 10]]]

print(list_elements[0])       # [1, 2, 3]
print(list_elements[0][1])    # 2

print(list_elements[3][1][2])     # 10
print(list_elements[3][1][1][0])  # 9
```

Иногда удобнее идти «ступеньками» через временные переменные:
```py
first = list_elements[0]
second_element = first[1]
print(second_element)  # 2
```

---

## 6) Изменение элементов во вложенных списках
Можно менять элементы на любом уровне вложенности:

```py
list_elements = [[1, 2], [3, 4], [5, 6]]

list_elements[0][1] = "two"   # меняем элемент внутри вложенного списка
list_elements[2] = "new"      # заменяем целиком подсписок
print(list_elements)
```

Если элемент — строка (immutable), то «изменение» = присваивание результата:
```py
list_elements = [[1, "two"], [3, 4]]
list_elements[0][1] = list_elements[0][1].upper()
print(list_elements)  # [[1, 'TWO'], [3, 4]]
```

Если элемент внутри — тоже список, его можно менять методами:
```py
list_elements = [[1, 2], [3, 4]]
list_elements[0].append("new value")
print(list_elements)  # [[1, 2, 'new value'], [3, 4]]
```

---

## 7) Итерация по вложенным спискам
### 7.1 Первый уровень
```py
list_elements = [[1, 2], [3, 4], [5, 6]]
for sublist in list_elements:
    print(sublist)
```

### 7.2 Все элементы (вложенные циклы)
```py
for sublist in list_elements:
    for item in sublist:
        print(item, end=" ")
```

### 7.3 Итерация с изменением (через индексы)
```py
for i, sublist in enumerate(list_elements):
    for j, item in enumerate(sublist):
        list_elements[i][j] = item + 1
print(list_elements)
```

---

## 8) Оператор `del`
`del` может:
- удалить элемент по индексу,
- удалить срез,
- удалить переменную (имя), уменьшая число ссылок на объект.

Синтаксис:
```py
del lst[index]
del lst[start:end]
del variable
```

Примеры:
```py
numbers = [10, 20, 30, 40]
del numbers[2]
print(numbers)  # [10, 20, 40]

numbers = [10, 20, 30, 40, 50]
del numbers[1:3]
print(numbers)  # [10, 40, 50]

numbers = [1, 2, 3]
del numbers[:]  # как clear()
print(numbers)  # []
```

Удаление переменной ≠ удаление объекта, если на объект ещё кто-то ссылается:
```py
a = [1, 2, 3]
b = a
del a
print(b)  # [1, 2, 3]
```

---

## 9) Копирование списков: ссылка vs shallow copy vs deep copy
### 9.1 Самая частая ошибка: «копия» через `=`
```py
original = [1, 2, 3]
copied = original     # это НЕ копия
copied[0] = 99
print(original)       # [99, 2, 3]
```

### 9.2 Поверхностное копирование (shallow copy)
Создаёт новый список, но вложенные элементы копируются как **ссылки**.

Способы:
- `lst.copy()`
- `lst[:]`
- `list(lst)`

```py
original = [1, 2, 3]
copied = original.copy()
copied[0] = 99
print(original)  # [1, 2, 3]
print(copied)    # [99, 2, 3]
```

Но на вложенных списках shallow copy «не спасает»:
```py
original = [[1, 2], [3, 4]]
shallow = original.copy()
shallow[0][0] = 99
print(original)  # [[99, 2], [3, 4]]  <- поменялся тоже!
```

### 9.3 Глубокое копирование (deep copy)
Создаёт независимую копию **всех уровней вложенности**.

```py
import copy

original = [[1, 2], [3, 4]]
deep = copy.deepcopy(original)
deep[0][0] = 99

print(original)  # [[1, 2], [3, 4]]
print(deep)      # [[99, 2], [3, 4]]
```

✅ Когда что использовать:
- обычный список без вложенных изменяемых объектов → достаточно shallow copy
- есть вложенные списки/словари, и ты будешь их менять → нужен `deepcopy`

---

## 10) Практическая работа (решение): фильтрация элементов в группах
Задача:
1) создать **глубокую копию** вложенного списка,
2) в копии удалить элементы, которые меньше **среднего значения** в каждой группе,
3) убедиться, что исходный список не изменился.

Дано:
```py
nested_list = [[10, 15, 20], [5, 25, 30], [35, 40, 80]]
```

Решение:
```py
import copy

nested_list = [[10, 15, 20], [5, 25, 30], [35, 40, 80]]
deep_copy = copy.deepcopy(nested_list)

for sublist in deep_copy:
    avg = sum(sublist) / len(sublist)

    # удаляем безопасно: идём с конца, чтобы не съезжали индексы
    for i in range(len(sublist) - 1, -1, -1):
        if sublist[i] < avg:
            del sublist[i]

print("Исходный список:", nested_list)
print("Глубокая копия после изменений:", deep_copy)
# [[15, 20], [25, 30], [80]]
```

---

## 11) Домашнее задание (решения)

### 11.1 Одно слово
Удалить строки, где больше одного слова, и привести одиночные слова к нижнему регистру.

Дано:
```py
text_list = ["Hello", "Python Programming", "World", "Advanced Topics", "Simple"]
```

Решение:
```py
text_list = ["Hello", "Python Programming", "World", "Advanced Topics", "Simple"]

result = []
for s in text_list:
    if len(s.split()) == 1:
        result.append(s.lower())

print("Обработанный список:", result)
# ['hello', 'world', 'simple']
```

---

### 11.2 Обновление цен товаров (скидка и таблица)
Нужно:
- ввести скидку в процентах,
- к каждому товару добавить новую цену (в список товара добавить элемент),
- вывести таблицу: имя, старая цена, новая цена (с `$` и 2 знаками).

Дано:
```py
products = [["Laptop", 1200], ["Mouse", 25], ["Keyboard", 75], ["Monitor", 200]]
```

Решение:
```py
products = [["Laptop", 1200], ["Mouse", 25], ["Keyboard", 75], ["Monitor", 200]]
discount = float(input("Введите скидку (в процентах): "))

for item in products:
    old_price = float(item[1])
    new_price = old_price * (1 - discount / 100)
    item.append(new_price)  # добавили новую цену третьим элементом

print("Товар       Старая цена   Новая цена")
for name, old_price, new_price in products:
    print(f"{name:<10} {old_price:>10.2f}$  {new_price:>10.2f}$")
```

---

## 12) Короткая шпаргалка
```text
b = a                    -> одна ссылка, не копия (опасно для list/dict/set)
id(obj)                  -> ID объекта (проверка: это один объект или два?)

Вложенность:
lst[i][j][k]             -> индексация уровнями

Удаление:
del lst[i]               -> удалить элемент
del lst[a:b]             -> удалить срез
del var                  -> удалить имя (объект жив, если есть другие ссылки)

Копирование:
lst.copy() / lst[:] / list(lst)     -> shallow copy (вложенные структуры всё ещё общие)
copy.deepcopy(lst)                  -> deep copy (полная независимость)

Удаление при обходе:
идти по индексам с конца (range(len-1, -1, -1)), чтобы индексы не смещались
```
