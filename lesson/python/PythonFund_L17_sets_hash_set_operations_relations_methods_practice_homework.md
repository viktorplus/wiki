# Python Fundamentals — Урок 17: множества (`set`), `hash()`, операции и отношения множеств

## 1) Множество (Set): что это
**Множество (`set`)** — изменяемая структура данных, которая хранит **уникальные** элементы в **неупорядоченном** виде.

Ключевые свойства:
- **уникальность**: дубликаты автоматически “схлопываются”;
- **нет порядка** (и нет индексов): нельзя обратиться `my_set[0]`;
- **быстрая проверка наличия**: `x in my_set`;
- хранение основано на **хешировании**.

Ограничение:
- элементы множества должны быть **хешируемыми** (обычно: `int`, `float`, `str`, `bool`, `tuple` из хешируемых элементов).
- списки/словари/множества внутри `set` хранить нельзя (они изменяемые → не хешируемые).

---

## 2) Создание множества
### 2.1 Через фигурные скобки
```py
unique_numbers = {1, 2, 3, 4, 5}
print(unique_numbers)
```

### 2.2 Пустое множество
⚠️ `{}` — это **словарь**, а не множество. Пустое множество создаём так:
```py
empty_set = set()
print(empty_set)
```

Проверка:
```py
empty = {}
print(type(empty))  # <class 'dict'>
```

---

## 3) `hash()` и хешируемость
### 3.1 Что такое хеш
**Хеш** — числовое значение фиксированной длины, вычисляемое хеш‑функцией из объекта (произвольной длины).  
В Python используется для быстрых структур: `set`, `dict`.

### 3.2 Хешируемые объекты
Условия хешируемости:
1) **неизменяемость** (immutable),
2) наличие метода `__hash__()`.

Примеры хешируемых:
```py
print(hash("hello"))
print(hash(42))
print(hash(True))

my_tuple = (1, 2, 3)
print(hash(my_tuple))
```

Пример НЕхешируемого (ошибка):
```py
my_list = [1, 2, 3]
# print(hash(my_list))  # TypeError: unhashable type: 'list'
```

✅ Почему важно: только хешируемые объекты могут быть элементами `set`, потому что `set` хранит элементы через их хеш‑коды.

---

## 4) Как множество хранится в памяти (идея)
`set` реализовано как **хеш‑таблица**:
- элемент хешируется (`hash(x)`),
- по хешу выбирается “слот” хранения,
- при коллизиях используются механизмы разрешения коллизий,
- из‑за этого порядок обхода не гарантирован.

Пример:
```py
my_set = {20, 10, 30, 40}
print(hash(20), hash(10), hash(30), hash(40))
print(my_set)  # порядок может выглядеть “случайным”
```

---

## 5) Преобразование в множество: `set(iterable)`
`set()` превращает любую коллекцию/итерируемый объект в множество и удаляет дубликаты.

```py
numbers = [1, 2, 2, 3, 4, 4, 5]
unique_numbers = set(numbers)
print(unique_numbers)

text = "hello"
unique_chars = set(text)
print(unique_chars)

r = set(range(10))
print(r)
```

Особенности:
- порядок не сохраняется,
- остаются только уникальные элементы.

---

## 6) Методы добавления/удаления элементов
| Метод | Что делает | Важное |
|---|---|---|
| `add(x)` | добавить элемент | если уже есть — ничего не меняется |
| `remove(x)` | удалить элемент | если нет — `KeyError` |
| `discard(x)` | удалить элемент | если нет — **ошибки нет** |
| `pop()` | удалить и вернуть “случайный” элемент | если пусто — `KeyError` |
| `clear()` | очистить множество | сделает пустым |
| `copy()` | копия множества | возвращает новый объект |

Примеры:
```py
s = {1, 2, 3}
s.add(4)
s.add(3)        # не добавится второй раз
print(s)

s.remove(2)     # ok
# s.remove(2)   # KeyError

s.discard(999)  # ошибки нет
print(s)

x = s.pop()     # удалит и вернёт элемент
print(x, s)

s.clear()
print(s)

a = {1, 2, 3}
b = a.copy()
b.add(4)
print(a, b)     # a не изменился
```

---

## 7) Функции и операторы для множеств
### 7.1 Встроенные функции
```py
my_set = {10, 20, 5, 8}
print(len(my_set))
print(min(my_set))
print(max(my_set))
print(sum(my_set))
print(sorted(my_set))  # вернёт СПИСОК
```

### 7.2 Операторы вхождения
```py
my_set = {1, 2, 3}
print(2 in my_set)      # True
print(4 not in my_set)  # True
```

---

## 8) Операции над множествами (union / intersection / difference / symmetric difference)

### 8.1 Виды методов
- **Неизменяющие**: возвращают новое множество (оригинал не трогают)
- **Изменяющие**: изменяют исходное множество “на месте”

### 8.2 Таблица операций
| Операция | Оператор | Неизменяющий | Изменяющий |
|---|---:|---|---|
| Объединение | `|` | `union()` | `update()` |
| Пересечение | `&` | `intersection()` | `intersection_update()` |
| Разность | `-` | `difference()` | `difference_update()` |
| Симм. разность | `^` | `symmetric_difference()` | `symmetric_difference_update()` |

### 8.3 Примеры
#### Объединение
```py
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1 | set2)
print(set1.union(set2))
print(set1)  # не изменился

set1.update(set2)
print(set1)  # изменился
```

#### Пересечение
```py
set1 = {1, 2, 3}
set2 = {2, 3, 4}

print(set1 & set2)
print(set1.intersection(set2))

set1.intersection_update(set2)
print(set1)
```

#### Разность
```py
set1 = {10, 20, 30}
set2 = {20, 30, 40}

print(set1 - set2)              # {10}
print(set1.difference(set2))    # {10}

set1.difference_update(set2)
print(set1)                     # {10}
```

#### Симметрическая разность
```py
set1 = {1, 2, 3}
set2 = {2, 3, 4}

print(set1 ^ set2)                        # {1, 4}
print(set1.symmetric_difference(set2))    # {1, 4}

set1.symmetric_difference_update(set2)
print(set1)                               # {1, 4}
```

---

## 9) Отношения между множествами
| Отношение | Оператор | Метод |
|---|---|---|
| подмножество | `<=`, `<` | `issubset()` |
| надмножество | `>=`, `>` | `issuperset()` |
| равенство | `==` | — |
| неравенство | `!=` | — |
| нет общих элементов | — | `isdisjoint()` |

Примеры:
```py
set1 = {1, 2, 3}
set2 = {1, 2}
set3 = {3, 2, 1}

print(set2 <= set1)          # True (подмножество)
print(set2 < set1)           # True (строгое подмножество)
print(set1 >= set2)          # True (надмножество)

print(set1 == set3)          # True (порядок не важен)

a = {1, 2}
b = {3, 4}
c = {2, 3}
print(a.isdisjoint(b))       # True
print(a.isdisjoint(c))       # False
```

---

## 10) Цикл по множеству
По множеству можно идти циклом `for`, но **порядок не гарантируется**:
```py
my_set = {10, 20, 30, 40, 50}
for item in my_set:
    print(item)
```

---

## 11) Быстрые ответы на задания (квиз)
1) `my_set = {5, 10, 15, 5, 20}` → вывод: **`{5, 10, 15, 20}`**  
2) `my_set = {my_list}` где `my_list` — список → **`TypeError`** (список не хешируемый)  
3) `my_set.add(3)` при наличии 3 → множество не меняется  
4) `my_set.remove(0)` если 0 нет → **`KeyError`**  
5) удалить без ошибки, если элемента нет → **`discard()`**  
6) `set1 | set2` → объединение  
7) изменяющее пересечение → **`intersection_update()`**  
8) `set1 - set2` → разность  

---

## 12) Практика (решения)

### 12.1 Уникальные символы строки (без пробелов)
Дано:
```py
text = "hello world"
```

Решение:
```py
text = "hello world"
unique_chars = set(text)
unique_chars.discard(" ")
unique_chars = list(unique_chars)
print("Уникальные символы:", unique_chars)
```

### 12.2 Одинаковые элементы в двух списках без повторов
Дано:
```py
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]
```

Решение:
```py
list1 = [1, 2, 3, 4, 5]
list2 = [3, 4, 5, 6, 7]

intersection = list(set(list1) & set(list2))
print("Пересечение:", intersection)
```

---

## 13) Домашнее задание (решения)

### 13.1 Проверка на подмножество (несколько способов)
Дано:
```py
set1 = {1, 2, 3, 4}
set2 = {2, 3}
```

**Способ 1: метод**
```py
print(set2.issubset(set1))
```

**Способ 2: оператор**
```py
print(set2 <= set1)
```

**Способ 3: без возможностей множеств (только цикл)**
```py
set1 = {1, 2, 3, 4}
set2 = {2, 3}

ok = True
for x in set2:
    if x not in set1:
        ok = False
        break

print(ok)
```

---

### 13.2 “Зеркальное подмножество” + разность
Дано:
```py
set1 = {2, 3, 4, 5, 6}
set2 = {4, 5}
```

Нужно: проверить подмножество **в обе стороны**, и если да — вывести разность (между “большим” и “меньшим”).

Решение:
```py
set1 = {2, 3, 4, 5, 6}
set2 = {4, 5}

if set2 <= set1:
    print("Подмножество: True")
    print("Разница:", set1 - set2)
elif set1 <= set2:
    print("Подмножество: True")
    print("Разница:", set2 - set1)
else:
    print("Подмножество: False")
```

---

## 14) Мини-шпаргалка
```text
Создание:
{1,2,3}          -> set
set()            -> пустое множество
{}               -> dict (НЕ set)

Только хешируемые элементы:
int, float, str, bool, tuple(...)
list/dict/set -> нельзя

Методы:
add, remove(KeyError), discard(no error), pop(KeyError если пусто), clear, copy

Операции:
A | B  (union)                 / A.update(B)
A & B  (intersection)          / A.intersection_update(B)
A - B  (difference)            / A.difference_update(B)
A ^ B  (symmetric_difference)  / A.symmetric_difference_update(B)

Отношения:
B <= A  / B.issubset(A)
A >= B  / A.issuperset(B)
A.isdisjoint(B) -> True если нет общих элементов
```
