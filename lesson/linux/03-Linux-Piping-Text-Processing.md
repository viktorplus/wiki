# Лекция 3: Piping и обработка текста в Linux

## Основные команды вывода

### head - вывод начала файла

```bash
head file.txt               # Первые 10 строк (по умолчанию)
head -n 20 file.txt         # Первые 20 строк
head -5 file.txt            # Первые 5 строк
head -n -5 file.txt         # Все строки кроме последних 5

# Примеры
head /etc/passwd            # Первые 10 пользователей
head -n 3 /var/log/syslog   # Первые 3 строки лога
```

**Назначение**: Команда выводит определенное количество строк с **начала** документа.

### tail - вывод конца файла

```bash
tail file.txt               # Последние 10 строк (по умолчанию)
tail -n 20 file.txt         # Последние 20 строк
tail -5 file.txt            # Последние 5 строк
tail -f file.txt            # Следить за файлом в реальном времени
tail -n +5 file.txt         # Все строки начиная с 5-й

# Примеры
tail /var/log/syslog        # Последние 10 строк системного лога
tail -f /var/log/apache2/access.log  # Мониторинг веб-сервера
tail -n 50 file.txt         # Последние 50 строк
```

**Назначение**: Команда выводит определенное количество строк с **конца** документа.

### echo - вывод текста

```bash
echo "Hello world"          # Вывести текст
echo $HOME                  # Вывести значение переменной
echo -n "Text"              # Без перевода строки
echo -e "Line1\nLine2"      # С интерпретацией спецсимволов

# Примеры
echo "Hello world"          # Вернет: Hello world
echo $USER                  # Вывести имя пользователя
echo $PATH                  # Вывести PATH
echo "Error" >&2            # Вывести в stderr
```

**Назначение**: Команда выводит текст или **значение переменной** в стандартный вывод.

### history - история команд

```bash
history                     # Показать всю историю
history 20                  # Последние 20 команд
history | grep ssh          # Найти команды с ssh
history -c                  # Очистить историю
history -d 123              # Удалить команду номер 123

# Примеры
history | tail -3           # Последние 3 команды
!123                        # Выполнить команду номер 123
!!                          # Повторить последнюю команду
!ssh                        # Повторить последнюю команду, начинающуюся с ssh
```

**Назначение**: Команда выводит **историю команд**, выполненных в терминале.

## Piping (Конвейеры) - работа с терминалом

### Основы Piping

**Pipe** (`|`) - перенаправляет вывод одной команды на вход другой команды.

### Примеры использования Pipe

#### Базовые примеры

```bash
# Вывод содержимого файла
cat /etc/group
# Выводит на экран все, что есть в файле /etc/group

# Подсчет строк в файле
cat /etc/group | wc -l
# Pipe перенаправит результат вывода всех данных в файле
# на команду wc -l, которая посчитает количество всех строк

# Простой вывод текста
echo "Hello world"
# Вернет: Hello world в стандартный вывод
```

#### Работа с head и tail

```bash
# Первые 10 строк файла
cat /etc/group | head
# Выведет на экран первые 10 строк из файла /etc/group
# По умолчанию - 10 строк, но количество можно менять через ключ -n

# Последние 10 строк файла
cat /etc/group | tail
# tail также по умолчанию показывает 10 строк, но из конца файла

# Последние 3 команды из истории
history | tail -3
# Покажет последние три команды из истории

# Сохранение в файл
history | tail -3 >> /tmp/file
# Дозаписали в файл эти три строки из истории, используя >>
```

### Комплексные примеры Piping

```bash
# Подсчет пользователей в системе
cat /etc/passwd | wc -l

# Поиск и подсчет
cat /var/log/syslog | grep "error" | wc -l
# Найти все строки с "error" и подсчитать их

# Сортировка и уникальные значения
cat file.txt | sort | uniq
# Отсортировать и удалить дубликаты

# Топ процессов по памяти
ps aux | sort -k 4 -nr | head -10
# Показать 10 процессов, использующих больше всего памяти

# Анализ логов
cat /var/log/auth.log | grep "Failed" | tail -20
# Последние 20 неудачных попыток входа

# Подсчет файлов
ls -la | wc -l
# Подсчитать количество файлов и директорий

# Фильтрация и форматирование
cat /etc/passwd | grep "/bin/bash" | cut -d: -f1
# Список пользователей с оболочкой bash
```

## Перенаправление вывода

### Операторы перенаправления

```bash
# Перезапись файла
echo "Start" > file.txt
command > output.txt

# Дозапись в файл
echo "Additional line" >> file.txt
command >> output.txt

# Примеры
date > /tmp/current_date.txt        # Записать дату в файл
echo "Log entry" >> /tmp/log.txt    # Дозаписать в лог
ls -la > /tmp/listing.txt           # Сохранить список файлов
history | tail -3 >> /tmp/file      # Дозаписать последние 3 команды
```

### Разница между > и >>

| Оператор | Действие | Пример |
|----------|----------|---------|
| `>` | Перезаписывает файл (создает новый или удаляет содержимое) | `echo "New" > file.txt` |
| `>>` | Дозаписывает в конец файла (не удаляет существующее содержимое) | `echo "Add" >> file.txt` |

## Работа с wc (Word Count)

```bash
wc file.txt                 # Строки, слова, байты
wc -l file.txt              # Только количество строк
wc -w file.txt              # Только количество слов
wc -c file.txt              # Только количество байтов
wc -m file.txt              # Только количество символов

# Примеры с pipe
cat /etc/passwd | wc -l     # Количество пользователей
ls -la | wc -l              # Количество файлов
history | wc -l             # Количество команд в истории
```

## Практические примеры

### Пример 1: Анализ файла группы

```bash
# Просмотр файла
cat /etc/group

# Подсчет количества групп
cat /etc/group | wc -l

# Первые 5 групп
cat /etc/group | head -5

# Последние 5 групп
cat /etc/group | tail -5

# Поиск конкретной группы
cat /etc/group | grep "sudo"
```

### Пример 2: Работа с историей команд

```bash
# Вся история
history

# Последние 10 команд
history | tail -10

# Последние 3 команды
history | tail -3

# Сохранить последние 5 команд в файл
history | tail -5 > /tmp/last_commands.txt

# Дозаписать историю в файл
history | tail -3 >> /tmp/history_log.txt

# Поиск команд с определенным словом
history | grep "apt"
```

### Пример 3: Мониторинг логов

```bash
# Последние записи системного лога
tail -20 /var/log/syslog

# Следить за логом в реальном времени
tail -f /var/log/syslog

# Найти ошибки
cat /var/log/syslog | grep -i "error"

# Подсчитать количество ошибок
cat /var/log/syslog | grep -i "error" | wc -l

# Последние 10 ошибок
cat /var/log/syslog | grep -i "error" | tail -10
```

### Пример 4: Работа с директориями

```bash
# Список всех файлов (включая скрытые)
ls -la

# Только директории
ls -la | grep "^d"

# Только файлы
ls -la | grep "^-"

# Подсчет файлов
ls -la | grep "^-" | wc -l

# Последние 4 строки из списка в корне
ls -la / | tail -4
```

## Комбинирование команд

### Последовательное выполнение

```bash
# С точкой с запятой (выполнится всегда)
command1 ; command2 ; command3

mkdir test ; cd test ; touch file.txt

# С && (следующая выполнится только при успехе предыдущей)
command1 && command2 && command3

mkdir test && cd test && echo "Success"

# С || (следующая выполнится только при ошибке предыдущей)
command1 || command2

cd /nonexistent || echo "Directory not found"
```

### Примеры комбинирования

```bash
# Создать директорию и файл
mkdir -p /home/user/start && touch /home/user/start/1.txt

# Записать и проверить
echo "Start" > file.txt && cat file.txt

# Добавить дату и просмотреть
date >> file.txt && cat file.txt

# Создать директорию, скопировать и проверить
mkdir -p /opt/task && cp file.txt /opt/task/start.txt && ls -l /opt/task
```

## Домашнее задание (JSLinux)

### Задание 1: Создать файл с директорией

```bash
# Создать необходимую директорию
mkdir -p /home/user/start

# Создать текстовый файл
touch /home/user/start/1.txt

# Или одной командой
mkdir -p /home/user/start && touch /home/user/start/1.txt
```

### Задание 2: Добавить слово в файл

```bash
# Добавить слово "Start" в файл
echo "Start" > /home/user/start/1.txt

# Проверить содержимое
cat /home/user/start/1.txt
```

### Задание 3: Дописать текущую дату

```bash
# Дописать дату в конец документа
date >> /home/user/start/1.txt

# Проверить содержимое
cat /home/user/start/1.txt
```

### Задание 4: Скопировать в /opt/task

```bash
# Создать необходимую директорию
mkdir -p /opt/task

# Скопировать файл
cp /home/user/start/1.txt /opt/task/start.txt

# Проверить
ls -l /opt/task
cat /opt/task/start.txt
```

### Задание 5: Дописать последние 4 строки из /

```bash
# Получить список ВСЕХ объектов в корне (включая скрытые)
ls -la /

# Дописать последние 4 строки в файл
ls -la / | tail -4 >> /opt/task/start.txt

# Проверить результат
cat /opt/task/start.txt
```

### Полное решение одним блоком

```bash
# Создаем структуру и первый файл
mkdir -p /home/user/start
touch /home/user/start/1.txt

# Добавляем "Start"
echo "Start" > /home/user/start/1.txt

# Дописываем дату
date >> /home/user/start/1.txt

# Создаем целевую директорию и копируем
mkdir -p /opt/task
cp /home/user/start/1.txt /opt/task/start.txt

# Дописываем последние 4 строки из списка корня
ls -la / | tail -4 >> /opt/task/start.txt

# Проверяем итоговый результат
echo "=== Содержимое /opt/task/start.txt ==="
cat /opt/task/start.txt
```

## Полезные команды для работы с текстом

### cut - вырезание полей

```bash
# Вырезать первое поле с разделителем :
cut -d: -f1 /etc/passwd
# Список всех пользователей

# Вырезать несколько полей
cut -d: -f1,3 /etc/passwd
# Имена пользователей и их UID

# Вырезать символы
cut -c1-10 file.txt
# Первые 10 символов каждой строки
```

### sort - сортировка

```bash
# Алфавитная сортировка
sort file.txt

# Числовая сортировка
sort -n numbers.txt

# Обратная сортировка
sort -r file.txt

# Сортировка по второму полю
sort -k2 file.txt

# Уникальные и отсортированные
sort -u file.txt
```

### uniq - удаление дубликатов

```bash
# Удалить последовательные дубликаты
sort file.txt | uniq

# С подсчетом
sort file.txt | uniq -c

# Только дубликаты
sort file.txt | uniq -d

# Только уникальные
sort file.txt | uniq -u
```

## Сложные примеры с Piping

### Анализ логов

```bash
# Топ-10 IP адресов в логе Apache
cat /var/log/apache2/access.log | awk '{print $1}' | sort | uniq -c | sort -rn | head -10

# Подсчет HTTP статусов
cat /var/log/apache2/access.log | awk '{print $9}' | sort | uniq -c | sort -rn

# Ошибки за последний час
cat /var/log/syslog | grep "$(date +%H):" | grep -i error
```

### Работа с системными данными

```bash
# Пользователи с bash оболочкой
cat /etc/passwd | grep "/bin/bash" | cut -d: -f1

# Количество процессов по пользователям
ps aux | awk '{print $1}' | sort | uniq -c | sort -rn

# Использование памяти процессами
ps aux | sort -k4 -rn | head -10 | awk '{print $4"% "$11}'
```

### Обработка файлов

```bash
# Найти самые большие файлы
find /home -type f -exec du -h {} + | sort -rh | head -20

# Подсчет типов файлов
find . -type f | awk -F. '{print $NF}' | sort | uniq -c | sort -rn

# Файлы, измененные сегодня
find /home -type f -mtime 0 | wc -l
```

## Полезные ссылки и ресурсы

### Команда awk

- [Команда awk - примеры использования в Linux и Unix / Хабр](https://habr.com/ru/articles/)
- Мощный инструмент для обработки текста и данных
- Поддержка условий, циклов и функций
- Идеален для работы с структурированными данными

### Команда sed

- [Команда SED в Linux/Unix с примерами / Хабр](https://habr.com/ru/articles/)
- Потоковый редактор для замены текста
- Поддержка регулярных выражений
- Автоматизация редактирования файлов

### Дополнительные ресурсы

- **JSLinux** - браузерная версия Linux для практики
- **explainshell.com** - объяснение команд
- **tldr.sh** - краткие примеры использования команд
- **regex101.com** - тестирование регулярных выражений

## Практические задания для закрепления

1. **Анализ системных файлов**
   - Подсчитайте количество пользователей в системе
   - Найдите пользователей с оболочкой bash
   - Выведите первые 5 и последние 5 групп

2. **Работа с логами**
   - Найдите все ошибки в системном логе
   - Подсчитайте количество предупреждений
   - Сохраните последние 50 записей в отдельный файл

3. **Обработка истории команд**
   - Сохраните последние 20 команд в файл
   - Найдите все команды, связанные с файлами
   - Создайте архив часто используемых команд

4. **Создание скриптов**
   - Напишите скрипт для ежедневного архивирования истории
   - Создайте скрипт мониторинга размера логов
   - Автоматизируйте поиск и отчет об ошибках

## Шпаргалка по Piping

```bash
# Базовые паттерны
command | grep "pattern"              # Фильтрация
command | wc -l                       # Подсчет строк
command | sort                        # Сортировка
command | uniq                        # Удаление дубликатов
command | head                        # Первые строки
command | tail                        # Последние строки

# Комбинированные
command | grep "pattern" | wc -l      # Подсчет совпадений
command | sort | uniq -c              # Частота уникальных значений
command | head -20 | tail -10         # Строки с 11 по 20
command | tee file.txt | grep "x"     # Сохранить и обработать

# С перенаправлением
command > file.txt                    # Записать
command >> file.txt                   # Дозаписать
command | tee file.txt                # Вывести и сохранить
command 2>&1 | tee log.txt            # Все потоки в файл и на экран
```

---

# ЧАСТЬ 2: ТЕКСТОВЫЕ РЕДАКТОРЫ VI И NANO

## Текстовый редактор Vi

### Что такое Vi?

**Vi** - один из наиболее популярных текстовых редакторов в мире UNIX-подобных операционных систем, включая Linux.

- **Год выпуска**: 1976 (почти 50 лет назад)
- **Особенности**: мощный, но требует изучения команд
- **Распространение**: присутствует практически на всех Unix/Linux системах
- **Файлы в Linux**: являются текстовыми

### Vim (Vi Improved)

**Vim** - усовершенствованный клон классического редактора vi.

**Возможности Vim:**
- Множество команд для редактирования
- Подсветка синтаксиса
- Расширяемость через плагины
- Многоуровневый процесс отмены (undo)
- Использование нескольких окон редактирования
- Мощные инструменты поиска и замены

## Режимы работы Vi/Vim

### Командный режим (Command Mode)

- **Назначение**: Выполнение команд
- **Действия**: перемещение по тексту, удаление символов, копирование и вставка
- **Индикатор**: символ `-` в нижнем левом углу
- **По умолчанию**: Vi запускается в этом режиме

### Режим вставки (Insert Mode)

- **Назначение**: Ввод и редактирование текста
- **Переход**: нажать клавишу `i` в командном режиме
- **Индикатор**: буква `I` в нижнем левом углу (вместо `-`)
- **Выход**: клавиша `Esc` для возврата в командный режим

## Основные команды Vi

### Сохранение и выход

```bash
ZZ                  # Сохранить и выйти (БОЛЬШИЕ БУКВЫ!)
:w                  # Сохранить, но остаться в редакторе
:wq                 # Сохранить и выйти
:x                  # Сохранить и выйти (аналогично :wq)
:q!                 # Выйти БЕЗ сохранения (отменить все изменения)
```

### Навигация

```bash
G (Shift + G)       # Перейти к последней строке в файле
gg                  # Перейти к первой строке
:n                  # Перейти к строке номер n
h, j, k, l          # Влево, вниз, вверх, вправо
0                   # В начало строки
$                   # В конец строки
```

### Поиск

```bash
/pattern            # Начать поиск вперед
?pattern            # Начать поиск назад
n                   # Следующее совпадение
N                   # Предыдущее совпадение
```

### Редактирование

```bash
i                   # Войти в режим вставки (перед курсором)
a                   # Войти в режим вставки (после курсора)
o                   # Новая строка ниже и режим вставки
O                   # Новая строка выше и режим вставки
Esc                 # Выйти из режима вставки в командный режим
```

### Удаление

```bash
dd                  # Удалить текущую строку
x                   # Удалить символ под курсором
Del                 # Удалить один символ
dw                  # Удалить слово
D                   # Удалить до конца строки
```

### Копирование и вставка

```bash
yy                  # Копировать текущую строку (yank)
p                   # Вставить после текущей строки/позиции
P                   # Вставить перед текущей строкой/позицией
```

### Отмена и повтор

```bash
u                   # Отменить последнее действие (undo)
Ctrl+r              # Повторить отмененное действие (redo)
.                   # Повторить последнюю команду
```

## Практическая работа с Vi

### Пример 1: Создание и редактирование файла

```bash
# 1. Создать и открыть файл
vi /tmp/file

# 2. Перейти в режим вставки
# Нажать: i

# 3. Написать текст
# Ввести: Hello from ICH!

# 4. Выйти из режима редактирования
# Нажать: Esc

# 5. Сохранить и выйти
# Ввести: :wq
# Или нажать: ZZ
```

### Пример 2: Добавление даты

```bash
# Добавить дату в файл
date >> /tmp/file

# Открыть файл для просмотра
vi /tmp/file
```

### Пример 3: Редактирование и удаление строки

```bash
# Открыть файл
vi /tmp/file

# В командном режиме:
# - Переместиться к нужной строке
# - Нажать: i (войти в режим вставки)
# - Изменить текст (заменить ICH на ваше имя)
# - Нажать: Esc (выйти в командный режим)

# Удалить строку с датой
# - Переместить курсор на строку с датой
# - Нажать: dd

# Если нужно отменить
# - Нажать: u

# Сохранить и выйти
# - Ввести: :wq
```

## Интерфейс Vi

При запуске Vi вы увидите:

```
~                                              [Пустые строки обозначены ~]
~
~
~
~
~
~
"/tmp/file" [New File]                         1,1           All
-                                               [Режим: - = командный, I = вставка]
```

**Элементы интерфейса:**
- **Тильды (~)**: Обозначают пустые строки (не печатаются в файле)
- **Нижняя строка**: Имя файла, позиция курсора, процент документа
- **Левый нижний угол**: Индикатор режима (`-` или `I`)

## Задание для закрепления Vi

**Практическое упражнение:**

1. Создать текстовый файл `file` в папке `/tmp` и открыть для редактирования
2. Перейти в режим вставки (нажать `i`)
3. Написать: `Hello from ICH!`
4. Выйти из режима редактирования (нажать `Esc`)
5. Сохранить документ и выйти (`:wq` или `ZZ`)
6. Добавить дату: `date >> /tmp/file`
7. Открыть файл снова: `vi /tmp/file`
8. Изменить содержимое (заменить ICH на ваше имя)
9. Удалить строку с датой командой `dd`
10. Сохранить и выйти

## Текстовый редактор Nano

### Что такое Nano?

**Nano** - простой текстовый редактор в командной строке с базовым, легким в использовании интерфейсом.

**Преимущества:**
- Не требует изучения сложных комбинаций клавиш
- Отличный выбор для новичков
- Интуитивно понятный интерфейс
- Подсказки всегда на экране

**Особенности:**
- Размер: около 600 КБ
- Может отсутствовать в некоторых минималистичных дистрибутивах
- Сразу открывается в режиме редактирования

### Запуск Nano

```bash
nano /tmp/file          # Открыть/создать файл
nano                    # Открыть пустой буфер
```

## Интерфейс Nano

```
  GNU nano 2.9.3                    /tmp/file                              

[Область редактирования - здесь вводится текст]




^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify
^X Exit        ^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell
```

**Элементы интерфейса:**
- **Верх**: Название файла и версия редактора
- **Центр**: Область редактирования (сразу активна)
- **Низ**: Подсказки по командам
- **Символ ^**: Означает клавишу `Ctrl`

### Основные команды Nano

```bash
Ctrl+X              # Выход (^X Exit)
Ctrl+O              # Сохранить (^O Write Out)
Ctrl+W              # Поиск (^W Where Is)
Ctrl+K              # Вырезать строку (^K Cut Text)
Ctrl+U              # Вставить (^U Uncut Text)
Ctrl+G              # Помощь (^G Get Help)
Ctrl+R              # Вставить файл (^R Read File)
Ctrl+\              # Найти и заменить (^\ Replace)

# Навигация
Ctrl+A              # В начало строки
Ctrl+E              # В конец строки
Ctrl+Y              # Страница вверх
Ctrl+V              # Страница вниз
```

### Работа с Nano

**Создание и редактирование:**

```bash
# 1. Открыть файл
nano /tmp/file

# 2. Сразу можно печатать
# (режим редактирования активен по умолчанию)

# 3. Для сохранения и выхода:
Ctrl+X              # Нажать для выхода
Y                   # Подтвердить сохранение (Yes)
Enter               # Подтвердить имя файла
```

**Поиск и замена:**

```bash
# В Nano:
Ctrl+W              # Открыть поиск
# Ввести текст для поиска
Enter               # Начать поиск

Ctrl+\              # Найти и заменить
# Ввести что искать
# Ввести на что заменить
A                   # Заменить все (All)
```

## Сравнение Vi и Nano

| Характеристика | Vi/Vim | Nano |
|----------------|--------|------|
| **Кривая обучения** | Крутая | Пологая |
| **Режимы** | Командный и вставки | Только редактирование |
| **Мощность** | Очень высокая | Базовая |
| **Скорость работы** | Высокая (после освоения) | Средняя |
| **Подсказки** | Нет (нужно знать команды) | Всегда на экране |
| **Распространенность** | Везде | Не всегда установлен |
| **Размер** | Больше | Меньше (~600 КБ) |
| **Для новичков** | Сложен | Идеален |
| **Для профи** | Отлично | Ограничен |

## Задание для закрепления редакторов

**Практическое упражнение:**

1. При помощи **Vi** создать текстовый документ: `/home/text_editors`
   ```bash
   vi /home/text_editors
   # Нажать: i
   # Ввести: I love vi
   # Нажать: Esc
   # Ввести: :wq
   ```

2. При помощи **Nano** добавить текст в тот же документ:
   ```bash
   nano /home/text_editors
   # Переместить курсор в конец
   # Нажать: Enter
   # Ввести: I love nano
   # Нажать: Ctrl+X
   # Нажать: Y
   # Нажать: Enter
   ```

---

# ЧАСТЬ 3: ПРОДВИНУТЫЕ КОМАНДЫ PIPING

## Команда df - информация о дисках

### Что такое df?

**df** (disk free) - команда для отображения информации о доступном дисковом пространстве на файловых системах.

### Использование df

```bash
# Базовое использование
df                      # Вывод в килобайтах

# Человекочитаемый формат
df -h                   # В Мб, Гб, Тб и т.д.

# Показать тип файловой системы
df -T

# Показать инодов
df -i

# Только определенная файловая система
df -h /
```

### Пример вывода df -h

```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        50G   24G   24G  47% /
tmpfs           3.9G     0  3.9G   0% /dev/shm
/dev/sda2       100G   40G   55G  42% /home
```

**Колонки:**
- **Filesystem**: Имя файловой системы/раздела
- **Size**: Общий размер
- **Used**: Использовано
- **Avail**: Доступно
- **Use%**: Процент использования
- **Mounted on**: Точка монтирования

## Команда grep - поиск текста

### Базовое использование grep

```bash
# Поиск строки в файле
grep "pattern" filename.txt

# Поиск в выводе другой команды
ls -l | grep "file"

# Поиск в нескольких файлах
grep "error" *.log
```

### Ключи grep

#### Основные опции

```bash
-i, --ignore-case       # Игнорировать регистр
-v, --invert-match      # Инвертировать (строки БЕЗ совпадений)
-w, --word-regexp       # Искать только целые слова
-r, -R, --recursive     # Рекурсивный поиск в директориях
-n, --line-number       # Показать номера строк
-c, --count             # Подсчитать количество совпадений
-l, --files-with-matches # Только имена файлов с совпадениями
```

#### Контекстные опции

```bash
-A N, --after-context=N     # N строк ПОСЛЕ совпадения
-B N, --before-context=N    # N строк ДО совпадения
-C N, --context=N           # N строк ВОКРУГ совпадения
```

### Примеры использования grep

```bash
# Игнорировать регистр
grep -i "error" /var/log/syslog

# Инвертировать поиск (строки без "root")
grep -v "root" /etc/passwd

# Только целые слова (важно для символов типа /)
grep -w "/" df_output.txt

# Рекурсивный поиск
grep -r "TODO" /home/user/projects

# С номерами строк
grep -n "error" logfile.txt

# Подсчитать совпадения
grep -c "failed" /var/log/auth.log

# Контекст: 3 строки до и после
grep -C 3 "exception" app.log
```

### grep -w: Поиск целых слов

**Проблема без -w:**

```bash
df -h | grep "/"
# Выведет ВСЕ строки с символом /
# Например: /dev/sda1, /home, /var/log
```

**Решение с -w:**

```bash
df -h | grep -w "/"
# Выведет ТОЛЬКО строку с корневым разделом /
```

## Команда awk - обработка текста

### Что такое awk?

**awk** - утилита командной строки и язык программирования для обработки и анализа текстовых данных.

**Название**: Акроним из первых букв фамилий создателей (Aho, Weinberger, Kernighan)

**Возможности:**
- Считывание строк текста
- Разбиение на поля (колонки)
- Выполнение операций над данными
- Условная обработка
- Математические вычисления

### Базовый синтаксис awk

```bash
awk 'pattern {action}' file

# Структура:
awk '{print $1}'        # Вывести первую колонку
awk '{print $1, $3}'    # Вывести 1-ю и 3-ю колонки
awk '{print $NF}'       # Последняя колонка
```

### Колонки (поля) в awk

```bash
$0      # Вся строка
$1      # Первая колонка
$2      # Вторая колонка
$3      # Третья колонка
$NF     # Последняя колонка
$(NF-1) # Предпоследняя колонка
```

### Примеры использования awk

```bash
# Вывести первую колонку
df -h | awk '{print $1}'

# Вывести 5-ю колонку (процент использования)
df -h | awk '{print $5}'

# Вывести несколько колонок
df -h | awk '{print $1, $5, $6}'

# С разделителем (delimiter)
awk -F: '{print $1}' /etc/passwd    # Имена пользователей
awk -F: '{print $1, $3}' /etc/passwd # Имя и UID

# Условная фильтрация
df -h | awk '$5 > 50 {print $0}'    # Диски >50% заполнения
awk -F: '$3 >= 1000 {print $1}' /etc/passwd  # UID >= 1000

# Математические операции
awk '{sum += $1} END {print sum}' numbers.txt
```

### Работа с таблицей как с данными

Представим вывод `df -h | grep -w /` как таблицу:

| $1 | $2 | $3 | $4 | $5 | $6 |
|----|----|----|----|----|-----|
| /dev/sda1 | 50G | 24G | 24G | 47% | / |

```bash
# Получить процент использования (5-я колонка)
df -h | grep -w / | awk '{print $5}'
# Результат: 47%
```

## Команда sed - потоковый редактор

### Что такое sed?

**sed** (Stream Editor) - утилита для выполнения текстовых преобразований в потоках данных.

**Принцип работы:**
- Читает входные данные построчно
- Применяет команды преобразования
- Выводит результат в стандартный вывод

**Основное применение:**
- Поиск и замена текста
- Удаление строк
- Вставка текста
- Автоматизация редактирования

### Базовый синтаксис sed

```bash
sed 's/old/new/' file           # Заменить первое вхождение
sed 's/old/new/g' file          # Заменить все вхождения (global)
sed -i 's/old/new/g' file       # Изменить файл на месте (in-place)
```

**Структура команды замены:**

```
sed 's/pattern/replacement/flags'
     │    │           │        │
     │    │           │        └─ Флаги (g, i, и т.д.)
     │    │           └────────── На что заменить
     │    └────────────────────── Что искать
     └─────────────────────────── s = substitute (замена)
```

### Флаги sed

```bash
g       # Global - заменить все вхождения в строке
i       # Ignore case - игнорировать регистр
1,2,3   # Заменить только n-ое вхождение
```

### Примеры замены с sed

```bash
# Простая замена
sed 's/apple/orange/' file.txt
# Заменит первое "apple" на "orange" в каждой строке

# Глобальная замена
sed 's/apple/orange/g' file.txt
# Заменит ВСЕ "apple" на "orange"

# Удалить символ %
sed 's/%//g' file.txt
# Удалит все знаки %

# Заменить в реальном файле
sed -i 's/user2/Ivan/g' /etc/group
# ВНИМАНИЕ: изменяет файл напрямую!

# Замена с pipe
echo "47%" | sed 's/%//g'
# Результат: 47
```

### Другие операции sed

```bash
# Удаление строк
sed '5d' file               # Удалить 5-ю строку
sed '1,3d' file             # Удалить строки 1-3
sed '/pattern/d' file       # Удалить строки с pattern

# Вывод строк
sed -n '5p' file            # Вывести только 5-ю строку
sed -n '10,20p' file        # Вывести строки 10-20
sed -n '/pattern/p' file    # Вывести строки с pattern

# Вставка текста
sed '5i\New line' file      # Вставить перед 5-й строкой
sed '5a\New line' file      # Вставить после 5-й строки
```

## Комплексный пример: Piping df, grep, awk, sed

### Задача

Получить значение занятого дискового пространства для корневого раздела **без знака %** и записать в файл.

**Из:**
```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        50G   24G   24G  47% /
```

**Получить:**
```
47
```

### Решение по шагам

```bash
# Шаг 1: Получить информацию о дисках
df -h

# Шаг 2: Отфильтровать только корневой раздел
df -h | grep -w /

# Шаг 3: Извлечь 5-ю колонку (процент)
df -h | grep -w / | awk '{print $5}'
# Результат: 47%

# Шаг 4: Удалить знак %
df -h | grep -w / | awk '{print $5}' | sed 's/%//g'
# Результат: 47

# Шаг 5: Записать в файл
df -h | grep -w / | awk '{print $5}' | sed 's/%//g' > /tmp/df
```

### Полная команда

```bash
df -h | grep -w / | awk '{print $5}' | sed 's/%//g' > /tmp/df
```

**Разбор:**
1. `df -h` - показать диски в человекочитаемом формате
2. `grep -w /` - только строка с корневым разделом `/`
3. `awk '{print $5}'` - взять 5-ю колонку (Use%)
4. `sed 's/%//g'` - удалить символ `%`
5. `> /tmp/df` - записать результат в файл

## Отличия awk и sed

### awk

**Специализация**: Анализ и обработка структурированных данных

**Когда использовать:**
- Работа с колонками/полями
- Вычисления и математика
- Условная обработка данных
- Создание отчетов
- Обработка CSV, лог-файлов

**Примеры:**
```bash
awk '{print $1}'                    # Извлечь колонку
awk '{sum += $1} END {print sum}'   # Суммировать
awk '$3 > 100 {print $0}'           # Фильтрация по условию
```

### sed

**Специализация**: Поиск и замена текста в потоках

**Когда использовать:**
- Замена текста
- Удаление/вставка строк
- Редактирование файлов
- Простые преобразования текста

**Примеры:**
```bash
sed 's/old/new/g'                   # Замена текста
sed '/pattern/d'                    # Удаление строк
sed -i 's/foo/bar/g' file          # Редактирование файла
```

### Сравнительная таблица

| Критерий | awk | sed |
|----------|-----|-----|
| **Основная задача** | Анализ данных | Замена текста |
| **Работа с колонками** | ✅ Отлично | ❌ Неудобно |
| **Математика** | ✅ Есть | ❌ Нет |
| **Условия** | ✅ Мощные | ⚠️ Базовые |
| **Замена текста** | ⚠️ Возможно | ✅ Отлично |
| **Сложность** | Средняя | Простая |
| **Язык программирования** | ✅ Да | ❌ Нет |

## Практическая работа

### Задание

1. Создайте файл `myfile.txt` по пути `/root/test3/`
2. Запишите в файл вывод команды `df -h`
3. Допишите в файл 9 первых строк из списка всех объектов корня
4. Допишите количество символов из трех последних строк файла `/etc/group`

### Решение

```bash
# 1. Создать директорию и файл с выводом df -h
mkdir -p /root/test3
df -h > /root/test3/myfile.txt

# 2. Дописать 9 первых строк из корня
ls -a / | head -9 >> /root/test3/myfile.txt

# 3. Получить количество символов и дописать
cat /etc/group | tail -3 | wc -m >> /root/test3/myfile.txt

# Проверить результат
cat /root/test3/myfile.txt
```

**Объяснение команд:**

```bash
df -h > /root/test3/myfile.txt
# Создать файл и записать информацию о дисках

ls -a / | head -9 >> /root/test3/myfile.txt
# ls -a / - все объекты в корне (включая скрытые)
# head -9 - первые 9 строк
# >> - дописать в файл

cat /etc/group | tail -3 | wc -m >> /root/test3/myfile.txt
# cat /etc/group - содержимое файла групп
# tail -3 - последние 3 строки
# wc -m - подсчитать символы
# >> - дописать результат
```

## Экспресс-тест

**Найдите НЕверное утверждение:**

1. Поток № 2 - это поток данных, которые оболочка выводит после выполнения каких-то действий
2. Grep - это функция поиска по символам
3. awk - это простая, но мощная утилита, которая анализирует текст и плавно преобразует его
4. df - команда, показывающая насколько занят диск

**Ответ:** Утверждение 1 неверно. Поток №2 (stderr) - это поток **ошибок**, а не данных после выполнения. Поток №1 (stdout) - это стандартный вывод данных.

## Домашнее задание (JSLinux)

### Задание

1. Записать в новый файл дату
2. Дописать информацию о занятом пространстве на корневом разделе (/)
3. Дописать три последних команды из истории
4. Дописать информацию из `/etc/passwd`, отфильтровав только строки со словом `cron`
5. Дописать количество строк со словом `root` из `/etc/group`
6. В текстовом редакторе добавить второй строкой фразу "Modified with text editor"
7. Экспортировать файл командой `export_file`

### Решение

```bash
# 1. Создать файл и записать дату
date > /tmp/homework.txt

# 2. Дописать информацию о корневом разделе
df -h | grep -w / >> /tmp/homework.txt

# 3. Дописать последние 3 команды из истории
history | tail -3 >> /tmp/homework.txt

# 4. Дописать строки с "cron" из /etc/passwd
cat /etc/passwd | grep "cron" >> /tmp/homework.txt

# 5. Дописать количество строк с "root" из /etc/group
cat /etc/group | grep "root" | wc -l >> /tmp/homework.txt

# 6. Открыть в текстовом редакторе и добавить строку
nano /tmp/homework.txt
# или
vi /tmp/homework.txt

# Для Vi:
# - Нажать: O (в первой строке создаст строку выше)
# - Или: перейти на вторую строку, нажать i
# - Ввести: Modified with text editor
# - Нажать: Esc
# - Ввести: :wq

# Для Nano:
# - Переместить курсор после первой строки
# - Нажать: Enter
# - Ввести: Modified with text editor
# - Нажать: Ctrl+X, Y, Enter

# 7. Экспортировать файл (только в JSLinux)
export_file /tmp/homework.txt
```

### Альтернативное решение (одна команда)

```bash
# Все в одной цепочке
date > /tmp/hw.txt && \
df -h | grep -w / >> /tmp/hw.txt && \
history | tail -3 >> /tmp/hw.txt && \
grep "cron" /etc/passwd >> /tmp/hw.txt && \
grep "root" /etc/group | wc -l >> /tmp/hw.txt
```

## Дополнительные полезные команды

### tee - вывод и запись одновременно

```bash
# Вывести на экран И записать в файл
df -h | tee disk_info.txt

# Дописать в файл
df -h | tee -a disk_info.txt

# Несколько файлов
ls -la | tee file1.txt file2.txt

# В комбинации
df -h | tee /tmp/disk.txt | grep "/"
```

### column - форматирование в колонки

```bash
# Красивый вывод таблицы
cat /etc/passwd | column -t -s:

# С grep и column
df -h | column -t
```

### paste - объединение файлов

```bash
# Объединить файлы построчно
paste file1.txt file2.txt

# С разделителем
paste -d',' file1.txt file2.txt
```

## Шпаргалка по редакторам

### Vi/Vim команды

```bash
# Режимы
i, a, o         # Войти в режим вставки
Esc             # Командный режим

# Сохранение
:w              # Сохранить
:wq, :x, ZZ     # Сохранить и выйти
:q!             # Выйти без сохранения

# Редактирование
dd              # Удалить строку
yy              # Копировать строку
p               # Вставить
u               # Отменить
.               # Повторить

# Навигация
G               # Конец файла
gg              # Начало файла
/pattern        # Поиск
```

### Nano команды

```bash
Ctrl+X          # Выход
Ctrl+O          # Сохранить
Ctrl+W          # Поиск
Ctrl+K          # Вырезать строку
Ctrl+U          # Вставить
Ctrl+\          # Найти и заменить
```

### Piping команды

```bash
df -h           # Информация о дисках
grep pattern    # Поиск текста
awk '{print $N}' # Извлечь колонку N
sed 's/old/new/g' # Замена текста
wc -l           # Подсчет строк
wc -m           # Подсчет символов
head -n N       # Первые N строк
tail -n N       # Последние N строк
```

---

**Ключевые навыки лекции:**
- Работа с текстовыми редакторами Vi и Nano
- Понимание режимов работы Vi
- Продвинутое использование команд df, grep, awk, sed
- Комплексные цепочки обработки данных через piping
- Фильтрация и преобразование текстовых данных
- Автоматизация обработки системной информации
