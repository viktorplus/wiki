# Урок 3. Pipe and redirection (Linux)

## 1. Стандартные потоки ввода/вывода

В Unix/Linux у каждого процесса по умолчанию есть три стандартных потока (числа — **дескрипторы** потока):

| № (FD) | Имя    | Назначение                         | Откуда / Куда по умолчанию           |
|--------|--------|------------------------------------|--------------------------------------|
| 0      | stdin  | стандартный **ввод** данных       | клавиатура пользователя              |
| 1      | stdout | стандартный **вывод** данных      | окно терминала                       |
| 2      | stderr | стандартный вывод **ошибок**      | окно терминала (отдельно от stdout)  |

- **stdin** — поток, через который программа получает данные (обычно с клавиатуры, но можно подать и из файла/другой команды).
- **stdout** — поток, через который программа выводит результат своей работы.
- **stderr** — поток для сообщений об ошибках (можно перенаправлять отдельно от stdout).
- **Дескриптор** — номер (0, 1, 2 …), которым ядро и программы обозначают конкретный поток ввода/вывода.

---

## 2. Как обрабатывается команда в Linux (на примере `date`)

1. **Разбор команды**
   - Пользователь вводит в терминале:
     ```bash
     date
     ```
   - Оболочка (shell) разбирает строку: имя команды (`date`) и аргументы (в данном случае их нет).

2. **Поиск исполняемого файла**
   - Shell ищет команду в каталогах из переменной окружения `PATH`:
     ```bash
     echo $PATH
     which date
     ```
   - Если файл найден (например, `/bin/date`), оболочка готова его запустить.

3. **Создание процесса и запуск**
   - Оболочка создаёт новый процесс и запускает в нём исполняемый файл `date`.

4. **Выполнение команды**
   - Код программы `date` выполняется и формирует результат — текущие дата и время.

5. **Вывод результата**
   - Команда пишет результат в **stdout**, поэтому мы видим строку с датой в терминале.

6. **Завершение процесса**
   - Процесс `date` завершается, управление возвращается оболочке, терминал ждёт следующую команду.

**Мини‑проверка для себя:**  
– Могу ли я сам найти, где лежит `date`? → `which date`  
– Понимаю ли я, что делает `PATH`? → показывает, где shell ищет команды.

---

## 3. Перенаправление потоков (redirection)

Перенаправление позволяет сказать оболочке: *куда* отправить вывод команды и *откуда* взять ей ввод.

### 3.1. Запись и дозапись в файл (stdout → файл)

**Перезаписать файл (создать или стереть старое содержимое):**
```bash
date > current_date.txt
```
- Если файла не было — он будет создан.
- Если файл был — его содержимое заменится новым.

**Дописать в конец файла (не стирая старое):**
```bash
date >> current_date.txt
```
- Если файла нет — он будет создан.
- Если есть — к концу добавится новая строка с датой.

**Посмотреть содержимое:**
```bash
cat current_date.txt
```

Итого:

| Оператор | Что делает                            |
|----------|---------------------------------------|
| `>`      | записать (перезаписать) в файл        |
| `>>`     | дописать в конец файла (append)       |

### 3.2. Ввод из файла (файл → stdin команды)

Команда берёт данные не с клавиатуры, а из файла:

```bash
cat < current_date.txt
```

Здесь `current_date.txt` подаётся в **stdin** команды `cat`, а результат `cat` выводит в stdout (терминал).

### 3.3. Комбинированное перенаправление

Одновременно читаем из файла и пишем результат в другой файл:

```bash
cat < current_date.txt > output.txt
```

- Ввод (`stdin`) `cat` берётся из `current_date.txt`.  
- Вывод (`stdout`) направляется в `output.txt` (перезаписывается/создаётся).

### 3.4. Перенаправление потока ошибок (stderr)

Иногда нужно записать не только обычный вывод, но и ошибки в файл.

Общий пример:
```bash
command > output_error.txt 2>&1
```

Разбор:
- `> output_error.txt` — перенаправить **stdout (1)** в файл `output_error.txt`.
- `2>&1` — перенаправить **stderr (2)** туда же, куда сейчас идёт stdout (1).  
  В итоге **и обычный вывод, и ошибки** оказываются в одном файле.

Полезно запомнить:

| Запись                 | Значение                               |
|------------------------|----------------------------------------|
| `1>`                   | перенаправить stdout (обычно можно не писать `1`) |
| `2>`                   | перенаправить stderr                   |
| `2>&1`                 | отправить stderr туда же, где stdout   |

---

## 4. Piping (конвейеры) — `|`

**Pipe** соединяет команды так, что **stdout первой становится stdin второй**:
```bash
команда1 | команда2 | команда3
```

- Данные не пишутся во временный файл — передаются напрямую через память.
- Можно строить длинные цепочки обработки данных.

### 4.1. Команды, с которыми работали

- `cat` — вывести содержимое файла в stdout.
- `wc` — посчитать строки, слова, байты:
  - `wc -l` – только строки,
  - `wc -w` – только слова,
  - `wc -c` – только байты.
- `head` — первые N строк файла (по умолчанию 10):
  ```bash
  head -n 5 file.txt   # первые 5 строк
  ```
- `tail` — последние N строк файла (по умолчанию 10):
  ```bash
  tail -n 20 file.txt  # последние 20 строк
  ```
- `echo` — вывести текст/значение переменной:
  ```bash
  echo "Hello world"
  echo $PATH
  ```
- `history` — показать историю введённых команд.

### 4.2. Примеры пайпов

**Посчитать количество строк в файле `/etc/group`:**
```bash
cat /etc/group | wc -l
```
Альтернативный вариант без `cat`:
```bash
wc -l < /etc/group
```

**Первые 10 строк файла `/etc/group`:**
```bash
cat /etc/group | head
```

**Последние 10 строк файла `/etc/group`:**
```bash
cat /etc/group | tail
```

**Последние 3 команды из истории:**
```bash
history | tail -3
```

**Дописать последние 3 команды из истории в файл `/tmp/file`:**
```bash
history | tail -3 >> /tmp/file
```

---

## 5. Что нужно уметь после урока

1. Объяснить, что такое `stdin`, `stdout`, `stderr` и какие у них номера дескрипторов.
2. По шагам рассказать, как shell выполняет команду (на примере `date`).
3. Использовать перенаправление:
   - `>` и `>>` для записи/дозаписи в файл,
   - `<` для чтения из файла,
   - комбинированные варианты,
   - запись ошибок через `2>` и `2>&1`.
4. Строить простые конвейеры с `|` и уверенно пользоваться командами `cat`, `wc`, `head`, `tail`, `echo`, `history`.

---

## 6. Домашнее задание (JS Linux)

Работаем в браузере в JSLinux.

1. **Создать директорию и файл**
   ```bash
   mkdir -p /home/user/start
   cd /home/user/start
   touch 1.txt
   ```

2. **Добавить слово `Start` в файл 1.txt**
   ```bash
   echo "Start" > 1.txt
   ```

3. **Дописать в конец файла текущую дату**
   ```bash
   date >> 1.txt
   ```

4. **Скопировать файл в `/opt/task/start.txt` (предварительно создать директорию)**
   ```bash
   mkdir -p /opt/task
   cp /home/user/start/1.txt /opt/task/start.txt
   ```

5. **Дописать в `/opt/task/start.txt` последние 4 строки списка всех объектов из корня `/` (включая скрытые)**

   Сначала выведем список и возьмём последние 4 строки, затем допишем их в файл:
   ```bash
   ls -la / | tail -4 >> /opt/task/start.txt
   ```

Если все шаги выполнены, в `/opt/task/start.txt` должны быть:
1. слово `Start`,
2. текущая дата,
3. четыре строки из конца вывода `ls -la /`.
