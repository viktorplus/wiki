# Урок 9. find, locate, bash scripts — loops and cycles

## 1) Команда `find`
`find` — команда для поиска файлов и каталогов **в реальной файловой системе**. Она ищет **рекурсивно**, начиная с указанного каталога.  
Пример:
```bash
find /path/to/search -name "*.txt"
```

### Особенности `find`
- Ищет “по факту” на диске → может быть медленнее на больших системах.
- Поддерживает сложные условия: имя, тип, размер, права, время изменения и т.д.

---

## 2) Команда `locate`
`locate` — быстрый поиск файлов **по базе данных** (индексу файловой системы).  
Пример:
```bash
locate "*.txt"
```

### Особенности `locate`
- Работает быстро, потому что ищет по базе.
- Результаты могут быть **неактуальными**, если база не обновлялась после изменений в ФС.
- По сути — поиск по имени (для сложных фильтров используем `find`).

### Обновление базы `locate`
Перед поиском рекомендуется обновлять базу:
```bash
sudo updatedb
```

---

## 3) Использование `find` (частые сценарии)

### 3.1. Поиск по имени/маске
```bash
find /path/to/search -name "file.txt"
find /path/to/search -name "*.jpg"
```

> Часто полезно: `-iname` (без учёта регистра)

### 3.2. Поиск по типу `-type`
```bash
find /path/to/search -type f   # файлы
find /path/to/search -type d   # директории
```

Справка по типам:
- `f` — обычный файл
- `d` — директория
- `l` — символическая ссылка
- `b` — блочные устройства (dev)
- `c` — символьные устройства (dev)
- `p` — именованные каналы
- `s` — сокеты

### 3.3. Поиск по размеру `-size`
```bash
find /path/to/search -name "*.txt" -size +1M
```
Найдёт все `.txt` **больше 1 MB**.

### 3.4. Поиск по дате изменения `-mtime`
```bash
find /path/to/search -mtime -5
```

Правила:
- `-mtime +N` — изменены **более** чем N дней назад
- `-mtime -N` — изменены **менее** чем N дней назад
- `-mtime N` — изменены **ровно** N дней назад

Комбинированный пример (плюс игнор ошибок):
```bash
find /home/ -mtime -5 -name "*.txt" -size +15k 2>/dev/null
```

### 3.5. Удаление найденного `-delete`
```bash
find -type f -name "*.old" -delete
find /path/to/search -type f -mtime +7 -delete
```
⚠️ Будь осторожен: удаление без подтверждения.

### 3.6. Выполнение действия для каждого найденного `-exec`
Поставить права 644 всем найденным файлам:
```bash
find /path/to/search -type f -exec chmod 644 {} \;
```

Копировать найденные `.txt` в `/home`:
```bash
find /root/ -type f -name "*.txt" -exec cp {} /home \;
```

---

## 4) Использование `locate` (примеры)

### 4.1. Поиск по имени/расширению
```bash
locate myfile.txt
locate "*.jpg"
```

### 4.2. Поиск в конкретном каталоге через regex
```bash
locate -r '/path/to/directory/*\.txt$'
```

---

## 5) Bash циклы (loops and cycles)

Циклы позволяют выполнять блок кода несколько раз — по диапазону значений или пока условие истинно.

### 5.1. `for`
```bash
for i in {1..5}
do
  echo "Number: $i"
done
```

### 5.2. `while`
```bash
counter=1
while [ $counter -le 5 ]
do
  echo "Counter: $counter"
  ((counter++))
done
```

### 5.3. Бесконечный цикл (однострочник)
```bash
while true; do echo "Alive" && sleep 1; done
```

---

## 6) Разбор скрипта (создание файлов → папка по дате → вывод содержимого)

Скрипт создаёт текстовые файлы с текущим временем, копирует их в каталог, названный текущей датой, затем печатает содержимое.

```bash
#!/bin/bash
#
DATE=`date '+%d-%m-%y'`
#echo $DATE

for i in {1..5}
do
  date +'%H-%M-%S' > File-$i.txt
  sleep 5
done

mkdir -p $DATE
cp File*.txt $DATE

for FILE in $DATE/*
do
  cat $FILE
done
```

Что делает:
- `DATE=...` — сохраняет дату в формате `день-месяц-год`
- цикл `for` создаёт 5 файлов `File-1.txt ... File-5.txt` с текущим временем
- после каждого файла делает паузу `sleep 5`
- создаёт папку с датой `mkdir -p $DATE`
- копирует файлы `File*.txt` в эту папку
- проходит по файлам папки и выводит их содержимое через `cat`

> Современная форма вместо обратных кавычек:
> `DATE=$(date '+%d-%m-%y')`

---

## 7) Домашнее задание (JSLinux) — что нужно сделать
Создать файл `myfirstbashscript.sh`, сделать исполняемым, завести переменную `USER` (ваше имя) и скрипт должен:

1) Написать дату  
2) Поприветствовать по имени: `hello $USER!`  
3) Написать, из какой директории он работает (обычно `pwd`)  
4) Вывести количество процессов с именем `bioset` **одним числом** (не учитывая `grep`)  
5) Вывести права на файл `/etc/passwd` в формате `-rw-r--r--` (только эту часть — через `awk`)  

### Подсказка: пример “скелета” решения
```bash
#!/bin/bash

USER="Viktor"

date
echo "hello $USER!"
pwd

ps -ef | grep bioset | grep -v grep | wc -l

ls -l /etc/passwd | awk '{print $1}'
```

Затем экспортировать итоговый файл (как в JSLinux): `export_file ...` (как требует платформа).
