# Урок 12. Merge и Rebase + amend/reset/checkout/revert (Git)

## 0) Темы урока
- `git merge` — что это и как применяется  
- `git rebase` — что это и как применяется  
- **Золотое правило rebase**  
- `git commit --amend`  
- `git reset` (`--soft`, `--mixed`, `--hard`)  
- `git checkout`  
- `git revert`  
- Отличия `revert` и `reset`

---

## 1) `git merge` — объединение веток

### Что делает
`git merge` объединяет изменения **из одной ветки в другую**. Git анализирует изменения и пытается объединить автоматически.  
Часто при merge создаётся **merge commit** (дополнительный коммит слияния), который сохраняет историю обеих веток.

### Базовый вариант (main + feature)
Вариант из урока:
```bash
git checkout feature
git merge main
```

Идея: ты стоишь на `feature` и “подтягиваешь” изменения `main` в `feature`.

---

## 2) `git rebase` — перебазирование коммитов

### Что делает
`git rebase` “переносит” (перебазирует) коммиты текущей ветки так, чтобы они применились **поверх** другой ветки.  
Результат — история становится **более линейной** (без merge-коммитов), но при этом Git записывает **новые коммиты** (история переписывается).

### Базовый вариант (feature поверх main)
```bash
git checkout feature
git rebase main
```

---

## 3) Merge vs Rebase — ключевые отличия

### История коммитов
- **Merge**: сохраняет историю обеих веток и обычно добавляет merge commit.  
- **Rebase**: переписывает историю (создаёт новые коммиты), делает историю линейной.

### “Чистота” истории
- **Merge**: иногда в истории много merge-коммитов (“мусорные” слияния).
- **Rebase**: история “чище” и прямее.

### Конфликты
И при merge, и при rebase конфликты возможны — их нужно решать вручную.

### Безопасность
- **Merge**: безопаснее для совместной работы, не переписывает историю.
- **Rebase**: опаснее на общих ветках, потому что меняет историю и может сломать синхронизацию у других.

---

## 4) Золотое правило `rebase`

**Никогда не делайте rebase на публичных (общедоступных) ветках.**  
Перед `git rebase` задай себе вопрос:  
> “Кто-нибудь ещё работает с этой веткой?”  
Если да — rebase **не делаем**.

### Почему это важно
Rebase создаёт новые коммиты, и ветка начинает “расходиться” с тем, что уже есть у других участников команды.

### Опасный момент: `git push --force`
После rebase Git может не дать запушить историю обычным `push`, и тогда некоторые используют:
```bash
git push --force
```
⚠️ Это перезаписывает ветку на сервере — делать только если понимаете последствия (и почти никогда не для main/master).

---

## 5) `git commit --amend` — изменить последний коммит

### Что делает
Позволяет **изменить последний коммит**, не создавая новый:
- исправить сообщение коммита
- добавить “забытые” файлы в последний коммит

### Мини-сценарий
```bash
git add forgotten.css
git commit --amend
```
Откроется редактор — можно поправить сообщение.  
⚠️ `--amend` меняет историю локально, поэтому аккуратно, если этот коммит уже отправлен другим.

---

## 6) `git reset` — откат состояния (перемещение HEAD)

`git reset` перемещает указатель `HEAD` (и/или ветку) на другой коммит и по-разному влияет на индекс и рабочую директорию.

### `--soft`
- HEAD “откатывается”,  
- изменения остаются **в индексе и в рабочей папке** (как будто коммит отменили, но всё подготовлено).

```bash
git reset --soft <commit>
```

### `--mixed` (по умолчанию)
- HEAD “откатывается”  
- **индекс сбрасывается**,  
- изменения остаются **в рабочей папке** (unstaged).

```bash
git reset <commit>
# то же, что --mixed
```

### `--hard`
- HEAD “откатывается”
- индекс сбрасывается
- рабочая папка откатывается  
⚠️ непроиндексированные изменения теряются безвозвратно.

```bash
git reset --hard <commit>
```

---

## 7) `git checkout` — переключение и восстановление

`git checkout` используется:
- переключаться между ветками
- создавать ветку от другой ветки/коммита
- восстанавливать файлы из определённого коммита (не из последней версии ветки)

Примеры:
```bash
git checkout feature
git checkout -b hotfix
git checkout <commit_hash>          # может привести к detached HEAD
# восстановление файла из коммита:
git checkout <commit_hash> -- path/to/file
```

---

## 8) `git revert` — “отмена коммита” безопасно для истории

### Что делает
`git revert` создаёт **новый коммит**, который отменяет изменения указанного коммита.

✅ Безопасно для публичных веток, потому что история не переписывается.

Пример:
```bash
git revert <commit_hash>
```

---

## 9) Revert vs Reset — разница в одном абзаце
- `revert` **создаёт новый коммит-откат**, история сохраняется → безопасно для общих веток.
- `reset` **перемещает HEAD/ветку назад**, может переписать историю → опаснее для общих веток.

---

## 10) Домашнее задание (логика шагов из урока)
1) Создать новый репозиторий GitHub и добавить `.gitignore`.  
2) Склонировать репозиторий на компьютер.  
3) Создать ветку `feature`, внести изменения в **2 файла**: `README.md` и `.gitignore`, закоммитить и запушить ветку.  
4) В ветке `feature` сделать `git commit --amend` и изменить сообщение коммита (добавить слово `ammend`).  
5) Переключиться на `main` и выполнить `git merge feature`.  
6) Создать `history.txt` (например: `history > history.txt`), закоммитить и запушить в `main`.

---

## Мини-шпаргалка команд
```bash
# merge / rebase
git checkout feature
git merge main
git rebase main

# amend
git add .
git commit --amend

# reset
git reset --soft <commit>
git reset --mixed <commit>
git reset --hard <commit>

# checkout
git checkout <branch>
git checkout -b <new_branch>
git checkout <commit> -- <file>

# revert
git revert <commit>

# опасно
git push --force
```
